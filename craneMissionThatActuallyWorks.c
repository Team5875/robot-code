#pragma config(Sensor, S1,     gyro,           sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S2,     leftSensor,     sensorEV3_Color)
#pragma config(Sensor, S3,     rightSensor,    sensorEV3_Color)
#pragma config(Motor,  motorA,          forklift,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          leftMotor,    tmotorEV3_Large, PIDControl, reversed, driveRight, encoder)
#pragma config(Motor,  motorC,          rightMotor,     tmotorEV3_Large, PIDControl, reversed, driveLeft, encoder)
#pragma config(Motor,  motorD,          sidelift,      tmotorEV3_Large, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
int gyroAngle;
int totalDrift;
int driftDir;
unsigned long driftTime;
unsigned long nextGyroCalcTime;

short forkRange=1052;
short sideRange=948;
short zero_fork, zero_side;
short absTarget_fork, absTarget_side;

void MechReset(bool up, bool left)
{
	if(up)
	{
		setMotorSpeed(forklift, -50);
		zero_fork=0;
	}
	else
	{
		setMotorSpeed(forklift, 50);
		zero_fork= forkRange;
	}
	sleep(150);
	while(abs(getMotorRPM(forklift))>10) sleep(50);
	setMotorSpeed(forklift, 0);
	resetMotorEncoder(forklift);
	if(left)
	{
		setMotorSpeed(sidelift, -50);
		zero_side=0;
	}
	else
	{
		setMotorSpeed(sidelift, 50);
		zero_side= sideRange;
	}
	sleep(150);
	while(abs(getMotorRPM(sidelift))>10) sleep(50);
	setMotorSpeed(sidelift, 0);
	resetMotorEncoder(sidelift);
}

void moveMech(bool fork, short target, short speed)
{
	if(fork)
	{
		absTarget_fork = target-zero_fork;
		if (getMotorEncoder(forklift) < (absTarget_fork))
		{
			//target is below
			setMotorSpeed(forklift,speed);
			while(getMotorEncoder(forklift)<=(absTarget_fork)) sleep(20);
		}
		else// target is above
		{
			setMotorSpeed(forklift,-speed);
			while(getMotorEncoder(forklift)>=(absTarget_fork)) sleep(20);
		}
		setMotorSpeed(forklift, 0);
	}
	else
	{
		absTarget_side = target-zero_side;
		if (getMotorEncoder(sidelift) < (absTarget_side))
		{
			//target is below
			setMotorSpeed(sidelift,speed);
			while(abs(getMotorEncoder(sidelift))<=(absTarget_side)) sleep(20);
		}
		else// target is above
		{
			setMotorSpeed(sidelift,-speed);
			while(abs(getMotorEncoder(sidelift))>=(absTarget_side)) sleep(20);
		}
		setMotorSpeed(sidelift, 0);
	}
}

void smoothLF(bool left_right, tSensors port, float mid, int speed, float kP)
{
	if (!left_right)
	{
		//left side of line case
		kP = kP*-1;// reverses the kp(scaling) value
	}

	float error = (getColorReflected(port) - mid)*kP;//calculates an error value and multiplies it by kP to scale it

	setMotorSpeed(leftMotor, speed - error); //subracts this scaled correction from the desired speed of the left motor
	setMotorSpeed(rightMotor, speed + error); //adds this scaled correction from the desired speed of the right motor
}

void singleMotorMove(tMotor port,int degs,int speed, bool stopMotor)
{
	int endPos = getMotorEncoder(port) - (degs * sgn(speed));
	setMotorSpeed(port, speed * sgn(degs));
	if(sgn(speed) * sgn(degs) == 1) while(getMotorEncoder(port) > endPos) sleep(10);
	else while(getMotorEncoder(port) < endPos) sleep(10);
	if(stopMotor) setMotorSpeed(port, 0);
}

void motorMoveSync(tMotor portA,tMotor portB, int degs,int speed, bool stopMotors)
{
	int endPos = getMotorEncoder(portA) - (degs * sgn(speed));
	setMotorSpeed(portA, speed * sgn(degs));
	setMotorSpeed(portB, speed * sgn(degs));
	if(sgn(speed) * sgn(degs) == 1) while(getMotorEncoder(portA) > endPos) sleep(10);
	else while(getMotorEncoder(portA) < endPos) sleep(10);
	if(stopMotors)
	{
		setMotorSpeed(portA, 0);
		setMotorSpeed(portB, 0);
	}
}

task main()
{
	MechReset(true, true);
	moveMech(false, 425, 50);
	moveMech(true, 385, 50);

	motorMoveSync(leftMotor, rightMotor, 1000, 50, false);

	while(getColorReflected(rightSensor) < 85)
	{
		smoothLF(true, leftSensor, 50, 25, 0.2);
	}

	motorMoveSync(leftMotor, rightMotor, 230, 10, false);

	setMotorSpeed(leftMotor, 0);
	setMotorSpeed(rightMotor, 10);

	singleMotorMove(rightMotor, 10, 20, true);

	sleep(100);
	moveMech(true, 0, 100);
	sleep(80);
	moveMech(true, 385, 100);
	sleep(100);
	moveMech(true, 50, 50);
	sleep(100);

	motorMoveSync(leftMotor, rightMotor, 700, -100, false);
	setMotorSpeed(leftMotor, 0);
	singleMotorMove(rightMotor, 400, -100, false);
	motorMoveSync(leftMotor, rightMotor, 7200, -100, true);

	displayBigTextLine(5, "%d millis", nPgmTime);
	sleep(10000);
	/**/

}
